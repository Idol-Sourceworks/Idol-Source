// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define FUNC_GENERATE_ALL(INNERMACRONAME) INNERMACRONAME(0); FUNC_GENERATE_ALL_BUT0( INNERMACRONAME )
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define DEFINE_MEMBER_ITER_RANGE_PARALLEL(N) template <typename OBJECT_TYPE, typename FUNCTION_CLASS, typename FUNCTION_RETTYPE FUNC_TEMPLATE_FUNC_PARAMS_##N FUNC_TEMPLATE_ARG_PARAMS_##N, typename ITERTYPE1, typename ITERTYPE2> void IterRangeParallel(OBJECT_TYPE *pObject, FUNCTION_RETTYPE ( FUNCTION_CLASS::*pfnProxied )( ITERTYPE1, ITERTYPE2 FUNC_BASE_TEMPLATE_FUNC_PARAMS_##N ), ITERTYPE1 from, ITERTYPE2 to FUNC_ARG_FORMAL_PARAMS_##N ) { const int MAX_THREADS = 16; int nIdle = g_pThreadPool->NumIdleThreads(); ITERTYPE1 range = to - from; int nThreads = min( nIdle + 1, range ); if ( nThreads > MAX_THREADS ) { nThreads = MAX_THREADS; } if ( nThreads < 2 ) { FunctorDirectCall( pObject, pfnProxied, from, to FUNC_FUNCTOR_CALL_ARGS_##N ); } else { ITERTYPE1 nIncrement = range / nThreads; CJobSet jobSet; while ( --nThreads ) { ITERTYPE2 thisTo = from + nIncrement; jobSet += g_pThreadPool->AddCall( pObject, pfnProxied, from, thisTo FUNC_FUNCTOR_CALL_ARGS_##N ); from = thisTo; } FunctorDirectCall( pObject, pfnProxied, from, to FUNC_FUNCTOR_CALL_ARGS_##N ); jobSet.WaitForFinish( g_pThreadPool ); } }
